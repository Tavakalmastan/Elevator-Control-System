module elevator_fsm ( 
    input clk, 
    input rst, 
    input [3:0] floor_request,  
    output reg [1:0] current_floor,  
    output reg door_open, 
    output reg [1:0] direction  
); 
 
    // --- FSM States --- 
    parameter IDLE = 3'b000; 
    parameter PRE_MOVE = 3'b001; // State to set direction 
    parameter MOVING = 3'b010; 
    parameter PRE_DOOR = 3'b011; // State to stop and clear request 
    parameter DOOR_OPEN = 3'b100; 
 
    // --- Direction Constants --- 
    parameter DIR_IDLE = 2'b00; 
    parameter DIR_UP = 2'b01; 
    parameter DIR_DOWN = 2'b10; 
 
 
 
    // --- Timers --- 
    parameter MOVE_TIME = 24'd10_000_000; // 0.1 sec (10,000,000 * 10ns clock) 
    parameter DOOR_TIME = 24'd5_000_000;  // 0.05 sec 
     
    // --- Internal Registers --- 
    reg [2:0] state, next_state; 
    reg [1:0] target_floor; 
    reg [3:0] requests; 
    reg [23:0] timer; 
 
    // --- Combinational Block: Next State Logic --- 
    always @(*) begin 
        next_state = state; // Default 
         
        case(state) 
            IDLE: 
                if (requests != 4'b0000) 
                    next_state = PRE_MOVE; 
             
            PRE_MOVE: 
                if (current_floor == target_floor) 
                    next_state = PRE_DOOR; // Already at the floor 
                else 
                    next_state = MOVING; // Need to move 
             
            MOVING: 
                // Stay in MOVING state until timer is done 
                if (timer == MOVE_TIME) begin 
                    // After timer, check if we've arrived 
                    if ((direction == DIR_UP && (current_floor + 1) == target_floor) ||  
                        (direction == DIR_DOWN && (current_floor - 1) == target_floor)) 
                    begin 
                        next_state = PRE_DOOR; // Arrived 
 
 
                    end 
                    else begin 
                        // Not arrived, but timer is up, so stay in MOVING 
                        // to move the next floor (timer will reset) 
                        next_state = MOVING;  
                    end 
                end 
             
            PRE_DOOR: 
                next_state = DOOR_OPEN; 
                 
            DOOR_OPEN: 
                if (timer == DOOR_TIME) 
                    next_state = IDLE; 
        endcase 
    end 
     
    // --- Sequential Block: State & Data Registers --- 
    always @(posedge clk or posedge rst) begin 
        if (rst) begin 
            state <= IDLE; 
            current_floor <= 2'b00; 
            door_open <= 1'b0; 
            direction <= DIR_IDLE; 
            requests <= 4'b0000; 
            target_floor <= 2'b00; 
            timer <= 24'd0; 
        end else begin 
            // Latch new requests 
            requests <= requests | floor_request; 
             
            // Update state 
            state <= next_state; 
             
 
 
            // --- Timer --- 
            // Reset timer on state change OR when it hits a limit 
            if (next_state != state || (state == MOVING && timer == MOVE_TIME) || (state == 
DOOR_OPEN && timer == DOOR_TIME)) 
                timer <= 24'd0; 
            else 
                timer <= timer + 1; 
                 
            // --- Main FSM Actions (on state entry/during state) --- 
            case(state) 
                IDLE: begin 
                    door_open <= 1'b0; 
                    direction <= DIR_IDLE; 
                     
                    // Find a target floor (simple priority logic) 
                    if (requests[0]) target_floor <= 2'b00; 
                    else if (requests[1]) target_floor <= 2'b01; 
                    else if (requests[2]) target_floor <= 2'b10; 
                    else if (requests[3]) target_floor <= 2'b11; 
                end 
                 
                PRE_MOVE: begin 
                    // Set direction based on target 
                    if (current_floor < target_floor) direction <= DIR_UP; 
                    else if (current_floor > target_floor) direction <= DIR_DOWN; 
                    else direction <= DIR_IDLE; 
                end 
                 
                MOVING: begin 
                    // Action happens when timer is done 
                    if (timer == MOVE_TIME) begin 
                        if (direction == DIR_UP) 
                            current_floor <= current_floor + 1; 
                        else if (direction == DIR_DOWN) 
 
 
                            current_floor <= current_floor - 1; 
                    end 
                end 
                 
                PRE_DOOR: begin 
                    // Arrived at floor, stop moving 
                    direction <= DIR_IDLE; 
                    // Clear the request bit 
                    requests <= requests & ~(1 << current_floor); 
                end 
                 
                DOOR_OPEN: begin 
                    door_open <= 1'b1; 
                end 
            endcase 
        end 
    end 
 
endmodule